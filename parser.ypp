%{
	#include "Utilities.h"
	#include "Tables.h"
	#include "Types.h"
	#include "hw3_output.hpp"
%}


%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%token CONST
%token TRUE
%token FALSE
%token RETURN
%token IF
%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token COMMA
%token ID
%token NUM
%token STRING

%right ASSIGN
%left OR
%left AND
%left RELOP_EQUAL
%nonassoc RELOP_COMPARE
%left BINOP_ADD
%left BINOP_MUL
%right NOT
%left LPAREN
%left RPAREN
%left LBRACE
%left RBRACE
%nonassoc ELSE


%%


Program									:	Funcs
													{check_main_exist(); close_scope();}
;

Funcs										:	/*epsilon*/
												|	FuncDecl
													Funcs
;

FuncDecl								:	RetType
													ID
													LPAREN
													Formals
													RPAREN
													{add_func_to_symbol_table($2->get_name(), $1->get_name(), $4->get_args_types());}
													LBRACE
													{open_scope(); add_func_args_to_symbol_table($4->get_args_types(), $4->get_args_names());}
													Statements
													RBRACE
													{close_scope();}
;

RetType									:	Type
													{$$ = new RetTypeCls($1->get_name());}
												|	VOID
													{$$ = new RetTypeCls("VOID");}
;

Formals									:	/*epsilon*/
													{$$ = new FormalsCls();}
												|	FormalsList
													{$$ = new FormalsCls($1->get_args_types(), $1->get_args_names());}
;

FormalsList							:	FormalDecl
													{$$ = new FormalsListCls(); $$->add_formal_decl($1);}
												|	FormalDecl
													COMMA
													FormalsList
													{$3->add_formal_decl($1);}
;

FormalDecl							:	TypeAnnotation
													Type
													ID
													{$$ = new FormalDeclCls($1->get_is_const(), $2->get_name(), $3->get_name());}
;

Statements							:	Statement
													{/* TODO */}
												|	Statements
													Statement
													{/* TODO */}
;

Statement								:	LBRACE
													Statements
													RBRACE
													{/* TODO */}
												|	TypeAnnotation
													Type
													ID
													SC
													{/* TODO */}
												|	TypeAnnotation
													Type
													ID
													ASSIGN
													Exp
													SC
													{/* TODO */}
												|	ID
													ASSIGN
													Exp
													SC
													{/* TODO */}
												|	Call
													SC
													{/* TODO */}
												|	RETURN
													SC
													{/* TODO */}
												|	RETURN
													Exp
													SC
													{/* TODO */}
												|	IF
													LPAREN
													Exp
													RPAREN
													Statement
													{/* TODO */}
												|	IF
													LPAREN
													Exp
													RPAREN
													Statement
													ELSE
													Statement
													{/* TODO */}
												|	WHILE
													LPAREN
													Exp
													RPAREN
													Statement
													{/* TODO */}
												|	BREAK
													SC
													{/* TODO */}
												|	CONTINUE
													SC
													{/* TODO */}
;

Call										:	ID
													LPAREN
													ExpList
													RPAREN
													{/* TODO */}
												|	ID
													LPAREN
													RPAREN
													{/* TODO */}
;

ExpList									:	Exp
													{/* TODO */}
												|	Exp
													COMMA
													ExpList
													{/* TODO */}
;

Type										:	INT
													{$$ = new TypeCls("INT");}
												|	BYTE
													{$$ = new TypeCls("BYTE");}
												|	BOOL
													{$$ = new TypeCls("BOOL");}
;

TypeAnnotation					:	/*epsilon*/
													{$$ = new TypeAnnotationCls(false);}
												|	CONST
													{$$ = new TypeAnnotationCls(true);}
;

Exp											:	LPAREN
													Exp
													RPAREN
													{/* TODO */}
												|	Exp
													BINOP_MUL
													Exp
													{/* TODO */}
												|	Exp
													BINOP_ADD
													Exp
													{/* TODO */}
												|	ID
													{/* TODO */}
												|	Call
													{/* TODO */ }
												|	NUM
													{/* TODO */}
												|	NUM
													B
													{/* TODO */}
												|	STRING
													{/* TODO */}
												|	TRUE
													{/* TODO */}
												|	FALSE
													{/* TODO */}
												|	NOT
													Exp
													{/* TODO */}
												|	Exp
													AND
													Exp
													{/* TODO */}
												|	Exp
													OR
													Exp
													{/* TODO */}
												|	Exp
													RELOP_COMPARE
													Exp
													{/* TODO */}
												|	Exp
													RELOP_EQUAL
													Exp
													{/* TODO */}
												|	LPAREN
													Type
													RPAREN
													Exp
													{/* TODO */}
;


%%


void yyerror(const char* input) {
	/* TODO */
	exit(1);
}


int main() {
	return yyparse();
}
