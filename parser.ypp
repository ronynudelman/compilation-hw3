%{
	#include "Utilities.h"
	#include "Tables.h"
	#include "Types.h"
	#include "hw3_output.hpp"
%}


%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%token CONST
%token TRUE
%token FALSE
%token RETURN
%token IF
%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token COMMA
%token ID
%token NUM
%token STRING

%right ASSIGN
%left OR
%left AND
%left RELOP_EQUAL
%nonassoc RELOP_COMPARE
%left BINOP_ADD
%left BINOP_MUL
%right NOT
%left LPAREN
%left RPAREN
%left LBRACE
%left RBRACE
%nonassoc ELSE


%%


Program		:	Funcs                                                     		{check_main_exist(); close_scope();}
;
Funcs		:	/*epsilon*/                                                  		{}
				|	FuncDecl Funcs                                              		{}
;
FuncDecl	:	RetType
						ID
						LPAREN
						Formals
						RPAREN
						{add_func_to_symbol_table($2->get_name(), $1->get_name(), $4->get_args_types());}
						LBRACE
						{open_scope(); add_func_args_to_symbol_table($4->get_args_types(), $4->get_args_names());}
						Statements
						RBRACE
						{close_scope();}
;
RetType		:	Type                                                         	{$$ = new RetTypeCls($1->get_name());}
					|	VOID                                                         	{$$ = new RetTypeCls("VOID");}
;
Formals		:	/*epsilon*/                                                  	{$$ = new FormalsCls();}
					|	FormalsList                                                  	{$$ = new FormalsCls($1->get_args_types(), $1->get_args_names());}
;
FormalsList	:	FormalDecl                       {$$ = new FormalsListCls(); $$->add_formal_decl($1);}
						|	FormalDecl COMMA FormalsList     {$3->add_formal_decl($1);}
;
FormalDecl	:	TypeAnnotation Type ID       {$$ = new FormalDeclCls($1->get_is_const(), $2->get_name(), $3->get_name());}
;
Statements	:	Statement                                                		{ }
						|	Statements Statement                                  			{ }
;
Statement	:	LBRACE Statements RBRACE                                     	{ }
					|	TypeAnnotation Type ID SC                                    	{ }
					|	TypeAnnotation Type ID ASSIGN Exp SC                         	{ }
					|	ID ASSIGN Exp SC                                             	{ }
					|	Call SC                                                      	{ }
					|	RETURN SC                                                    	{ }
					|	RETURN Exp SC                                                	{ }
					|	IF LPAREN Exp RPAREN Statement                               	{ }
					|	IF LPAREN Exp RPAREN Statement ELSE Statement                	{ }
					|	WHILE LPAREN Exp RPAREN Statement                            	{ }
					|	BREAK SC                                                     	{ }
					|	CONTINUE SC                                                  	{ }
;
Call		:	ID LPAREN ExpList RPAREN                                     		{ }
				|	ID LPAREN RPAREN                                             		{ }
;
ExpList		:	Exp                                                        		{ }
					|	Exp COMMA ExpList                                            	{ }
;
Type		:	INT                                                          		{$$ = new TypeCls("INT");}
				|	BYTE                                                         		{$$ = new TypeCls("BYTE");}
				|	BOOL                                                         		{$$ = new TypeCls("BOOL");}
;
TypeAnnotation	:	/*epsilon*/                               							{ }
								|	CONST                                                   { }
;
Exp			:	LPAREN Exp RPAREN                                          			{ }
				|	Exp BINOP_MUL Exp                                           		{ }
				|	Exp BINOP_ADD Exp                                            		{ }
				|	ID                                                           		{ }
				|	Call                                                         		{ }
				|	NUM                                                          		{ }
				|	NUM B                                                        		{ }
				|	STRING                                                       		{ }
				|	TRUE                                                         		{ }
				|	FALSE                                                        		{ }
				|	NOT Exp                                                      		{ }
				|	Exp AND Exp                                                  		{ }
				|	Exp OR Exp                                                   		{ }
				|	Exp RELOP_COMPARE Exp                                        		{ }
				|	Exp RELOP_EQUAL Exp                                          		{ }
				|	LPAREN Type RPAREN Exp						 															{ }
;


%%


void yyerror(const char* input) {
	// TODO - need to complete
	exit(1);
}


int main() {
	return yyparse();
}
