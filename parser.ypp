%{
	#include "Utilities.h"
	#include "Tables.h"
	#include "Types.h"
	#include "hw3_output.hpp"
%}


%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%token CONST
%token TRUE
%token FALSE
%token RETURN
%token IF
%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token COMMA
%token ID
%token NUM
%token STRING

%right ASSIGN
%left OR
%left AND
%left RELOP_EQUAL
%nonassoc RELOP_COMPARE
%left BINOP_ADD
%left BINOP_MUL
%right NOT
%left LPAREN
%left RPAREN
%left LBRACE
%left RBRACE
%nonassoc ELSE


%%


Program											:	Funcs
													{check_main_exist(); close_scope();}
;

Funcs											:	/*epsilon*/
												|	FuncDecl
													Funcs
;

FuncDecl										:	RetType
													ID
													LPAREN
													Formals
													RPAREN
													{add_func_to_symbol_table($2->get_name(), $1->get_name(), $4->get_args_types());}
													LBRACE
													{open_scope(); add_func_args_to_symbol_table($4->get_args_types(), $4->get_args_names());}
													Statements
													RBRACE
													{close_scope();}
;

RetType									:	Type
													{$$ = new RetTypeCls($1->get_name());}
												|	VOID
													{$$ = new RetTypeCls("VOID");}
;

Formals											:	/*epsilon*/
													{$$ = new FormalsCls();}
												|	FormalsList
													{$$ = new FormalsCls($1->get_args_types(), $1->get_args_names());}
;

FormalsList									:	FormalDecl
													{$$ = new FormalsListCls(); $$->add_formal_decl($1);}
												|	FormalDecl
													COMMA
													FormalsList
													{$$ = new FormalsListCls($3->get_args_types(),$3->get_args_names()); $$->add_formal_decl($1); }
;

FormalDecl							:	TypeAnnotation
													Type
													ID
													{$$ = new FormalDeclCls($1->get_is_const(), $2->get_name(), $3->get_name());}
;

Statements							:	Statement
													{/* TODO */}
												|	Statements
													Statement
													{/* TODO */}
;

Statement										:	LBRACE
													{open_scope();}
													Statements
													RBRACE
													{close_scope();}
												|	TypeAnnotation
													Type
													ID
													SC
													{check_assign_to_const($1->get_is_const()); add_var_to_symbol_table($1->get_is_const(),$2->get_name(), $3->get_name());}
												|	TypeAnnotation
													Type
													ID
													ASSIGN
													Exp
													SC
													{check_valid_types_for_assign($2->get_name(), $5->get_type()); add_var_to_symbol_table($1->get_is_const(),$2->get_name(), $3->get_name());}
												|	ID
													ASSIGN
													Exp
													SC
													{check_var_valid_for_assign($1->get_name()); std::string id_type = get_id_type($1->get_name()); check_valid_types_for_assign(id_type, $3->get_type());}
												|	Call
													SC
													{/* TODO */}
												|	RETURN
													SC
													{/* TODO */}
												|	RETURN
													Exp
													SC
													{/* TODO --> check that exp-return type matches the function */}
												|	IF
													LPAREN
													Exp
													RPAREN
													Statement
													{/* TODO --> open scope for if-itself, open scope for if-block*/}
												|	IF
													LPAREN
													Exp
													RPAREN
													Statement
													ELSE
													Statement
													{/* TODO --> open scope for if-itself (ensure exp is boolean), open scope for if-block, close both(?) and open scope for else*/}
												|	WHILE
													LPAREN
													Exp
													RPAREN
													Statement
													{/* TODO --> open scope for while-itself (ensure exp is boolean), open scope for while-block*/}
												|	BREAK
													SC
													{/* TODO --> ensure we are in while loop*/}
												|	CONTINUE
													SC
													{/* TODO --> what is there to do? */}
;

Call											:	ID
													LPAREN
													ExpList
													RPAREN
													{/* TODO --> calling a func. ensure func exists & right params (ExpList need to have arg_vector)*/}
												|	ID
													LPAREN
													RPAREN
													{/* TODO --> calling a func. ensure func exists & requires no params*/}
;

ExpList	/*basically FormalsList...*/			:	Exp
													{/* TODO */}
												|	Exp
													COMMA
													ExpList
													{/* TODO */}
;

Type										:	INT
													{$$ = new TypeCls("INT");}
												|	BYTE
													{$$ = new TypeCls("BYTE");}
												|	BOOL
													{$$ = new TypeCls("BOOL");}
;

TypeAnnotation					:	/*epsilon*/
													{$$ = new TypeAnnotationCls(false);}
												|	CONST
													{$$ = new TypeAnnotationCls(true);}
;

Exp												:	LPAREN
													Exp
													RPAREN
													{$$ = new ExpCls($2->get_type());}
												|	Exp
													BINOP_MUL
													Exp
													{$$ = new ExpCls(handle_binop_exp($1->get_type(), $3->get_type()));}
												|	Exp
													BINOP_ADD
													Exp
													{$$ = new ExpCls(handle_binop_exp($1->get_type(), $3->get_type()));}
												|	ID
													{$$ = new ExpCls(get_id_type($1->get_name()));}
												|	Call
													{/* TODO */ }
												|	NUM
													{$$ = new ExpCls("INT");}
												|	NUM
													B
													{$$ = new ExpCls("BYTE");}
												|	STRING
													{$$ = new ExpCls("STRING");}
												|	TRUE
													{$$ = new ExpCls("BOOL");}
												|	FALSE
													{$$ = new ExpCls("BOOL");}
												|	NOT
													Exp
													{check_matching_types("BOOL", $2->get_type()); $$ = new ExpCls($2->get_type());}
												|	Exp
													AND
													Exp
													{check_matching_types("BOOL", $1->get_type()); check_matching_types("BOOL", $3->get_type()); $$ = new ExpCls($1->get_type());}
												|	Exp
													OR
													Exp
													{check_matching_types("BOOL", $1->get_type()); check_matching_types("BOOL", $3->get_type()); $$ = new ExpCls($1->get_type());}
												|	Exp
													RELOP_COMPARE
													Exp
													{handle_relop_exp($1->get_type(), $3->get_type()); $$ = new ExpCls("BOOL");}
												|	Exp
													RELOP_EQUAL
													Exp
													{handle_relop_exp($1->get_type(), $3->get_type()); $$ = new ExpCls("BOOL");}
												|	LPAREN
													Type
													RPAREN
													Exp
													{handle_cast_exp($2->get_name(), $4->get_type()); $$ = new ExpCls($2->get_name());}
;


%%


void yyerror(const char* input) {
	/* TODO */
	exit(1);
}


int main() {
	return yyparse();
}
